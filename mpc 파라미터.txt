Horizon: 30
r=0.55
Q_.diagonal() << 1.5, 1.5, 1.0, 0.5, 0.0, 0.0;
R_.diagonal() << 200.0, 1.0;
slack_weight_ = 500000.0;

horizon: 20 → 30

이유: 시속 2~3m/s로 달릴 때 2초 앞(20 step)만 보면 제동 거리가 부족할 수 있습니다. 3초 앞(30 step)을 보게 하여 장애물 발견 즉시 감속 계획을 세우게 했습니다.

Q (x, y): 10.0 → 1.5
이유: 경로를 너무 정확히 따라가려다 보면, 장애물을 피할 때도 "다시 경로로 복귀해야 해!"라며 핸들을 급하게 꺾게 되어 진동이 발생합니다. 이를 느슨하게 풀어주어 부드럽게 피하게 했습니다.
R (steer): 100.0 → 200.0

이유: 고속에서는 작은 조향각도 큰 횡력이 됩니다. 핸들 변화에 비싼 비용을 매겨서, MPC가 최대한 직선에 가까운 부드러운 핸들링을 찾도록 유도했습니다.

Q vs R 은 비율로 파악하기

double dynamic_speed = target_speed_ * (1.0 - 0.6 * steering_ratio); 
감속 주행

dynamic_speed = std::max(dynamic_speed, 1.0);
최소속도


부리단의 당나귀(Buridan's Ass)